{
  "version": "0.0.1",
  "sql": "CREATE SCHEMA IF NOT EXISTS elwood;\n\ngrant usage on schema elwood to postgres, anon, authenticated, service_role;\nalter default privileges in schema elwood grant all on tables to postgres, anon, authenticated, service_role;\nalter default privileges in schema elwood grant all on functions to postgres, anon, authenticated, service_role;\nalter default privileges in schema elwood grant all on sequences to postgres, anon, authenticated, service_role;\n\n\n-- NODE_TYPE\nDROP TYPE IF EXISTS public.elwood_node_type CASCADE;\nCREATE TYPE public.elwood_node_type AS ENUM (\n    'TREE',\n    'BLOB',\n    'BUCKET'\n);\n\n-- NODE\nDROP TYPE IF EXISTS public.elwood_node CASCADE;\nCREATE TYPE public.elwood_node AS  (\n    \"id\" text,\n    \"object_id\" uuid,\n    \"type\" public.elwood_node_type, \n    \"prefix\" text[],\n    \"name\" text,\n    \"mime_type\" text,\n    \"size\" int    \n);\n\n\nDROP TYPE IF EXISTS public.elwood_storage_search_result CASCADE;\nCREATE TYPE public.elwood_storage_search_result AS (\n    name text,\n    id uuid,\n    updated_at timestamptz,\n    created_at timestamptz,\n    last_accessed_at timestamptz,\n    metadata jsonb\n);\n\nDROP TYPE IF EXISTS public.elwood_get_node_result CASCADE;\nCREATE TYPE public.elwood_get_node_result AS  (\n  \"node\" public.elwood_node,\n  \"parent\" public.elwood_node,\n  \"children\" public.elwood_node[],\n  \"key_children\" text[]\n);\n\n\nDROP TYPE IF EXISTS public.elwood_node_tree CASCADE;\nCREATE TYPE public.elwood_node_tree AS  (\n  \"node\" public.elwood_node,\n  \"id\" text,\n  \"parent\" text\n);\n\nDROP TYPE IF EXISTS public.elwood_get_node_tree_result CASCADE;\nCREATE TYPE public.elwood_get_node_tree_result AS  (\n  \"rootNodeId\" text,\n  \"expandedIds\" text[],\n  \"tree\" public.elwood_node_tree[]\n);\n\nDROP TYPE IF EXISTS public.elwood_member_type CASCADE;\nCREATE TYPE public.elwood_member_type AS ENUM (\n  'USER',\n  'TEAM'\n);\n\n--\n-- @@ NAMESPACE: ELWOOD\n--\n\nDROP TYPE IF EXISTS elwood.get_node_leaf_result CASCADE;\nCREATE TYPE elwood.get_node_leaf_result AS (\n  \"node\" public.elwood_node\n);\n\nDROP TYPE IF EXISTS elwood.follow_type CASCADE;\nCREATE TYPE elwood.follow_type AS ENUM (\n  'SAVE',\n  'SUBSCRIBE'\n);\n\nDROP TYPE IF EXISTS elwood.member_role CASCADE;\nCREATE TYPE elwood.member_role AS ENUM (\n  'ADMIN',\n  'MANAGER',\n  'MEMBER'\n);\n\nDROP TYPE IF EXISTS elwood.activity_type CASCADE;\nCREATE TYPE elwood.activity_type AS ENUM (\n    'COMMENT',\n    'REACTION',\n    'LIKE'\n);\n\n\n\nCREATE TABLE elwood.member (\n  \"instance_id\" uuid NOT NULL DEFAULT '00000000-0000-0000-0000-000000000000',\n  \"id\" uuid NOT NULL DEFAULT extensions.uuid_generate_v4(),\n  \"user_id\" uuid NOT NULL,\n  \"type\" public.elwood_member_type NOT NULL DEFAULT 'USER',\n  \"username\" text NULL,\n  \"display_name\" text NULL,\n  \"added_by_user_id\" uuid NULL,\n  \"role\" elwood.member_role NOT NULL DEFAULT 'MEMBER',\n  \"created_at\" timestamptz default now(),\n  \"updated_at\" timestamptz default now(),\n\n  CONSTRAINT \"elwood_member_user_id\" FOREIGN KEY (\"user_id\") REFERENCES \"auth\".\"users\"(\"id\"),\n  CONSTRAINT \"elwood_member_added_by_user_id\" FOREIGN KEY (\"added_by_user_id\") REFERENCES \"auth\".\"users\"(\"id\"),\n  PRIMARY KEY (\"id\")\n);\n\n\nCREATE UNIQUE INDEX IF NOT EXISTS elwood_idx_member_user_id ON elwood.member(\"instance_id\", \"user_id\");\nCREATE UNIQUE INDEX IF NOT EXISTS elwood_idx_member_username ON elwood.member(\"instance_id\", \"username\");\nalter table elwood.\"member\" enable row level security;\n\nDROP FUNCTION IF EXISTS elwood.is_a_member() CASCADE;\ncreate function elwood.is_a_member()\nreturns boolean\nlanguage plpgsql\nsecurity definer\nas $$\nbegin\n  return exists (\n    select 1 from elwood.member\n    where auth.uid() = user_id \n  );\nend;\n$$;\n\n\nCREATE VIEW public.elwood_member with (security_invoker=on)\n  AS SELECT \n    \"id\",\n    \"user_id\",\n    \"type\",\n    \"username\",\n    \"display_name\",\n    \"added_by_user_id\",\n    \"role\",\n    \"created_at\",\n    \"updated_at\"\n  FROM elwood.member;\n\ncreate policy \"Members can view all members.\"\non elwood.member for select\nto authenticated\nusing (elwood.is_a_member());\n\ncreate policy \"Member can update their own member row.\"\non elwood.member for update\nto authenticated           \nusing ( auth.uid() = user_id )\nwith check ( auth.uid() = user_id ); \ncreate table elwood.setting (\n  \"instance_id\" uuid not null default '00000000-0000-0000-0000-000000000000',\n  \"name\" varchar(20) not null primary key,\n  \"value\" jsonb not null default '{}'::jsonb,\n  \"created_at\" timestamptz default now(),\n  \"updated_at\" timestamptz default now()\n);\n\ncreate unique index if not exists elwood_idx_settings_name on elwood.setting (\n  \"instance_id\",\n  \"name\"\n);\n\nalter table elwood.\"setting\" enable row level security;\n\n\n\nCREATE TABLE IF NOT EXISTS elwood.activity (\n  \"instance_id\" uuid NOT NULL DEFAULT '00000000-0000-0000-0000-000000000000',\n  \"id\" uuid NOT NULL DEFAULT uuid_generate_v4(),\n  \"user_id\" uuid NOT NULL,\n  \"member_id\" uuid NOT NULL,\n  \"asset_id\" text NOT NULL,\n  \"asset_type\" TEXT NOT NULL,\n  \"is_resolved\" BOOLEAN NOT NULL DEFAULT FALSE,\n  \"is_deleted\" BOOLEAN NOT NULL DEFAULT FALSE,\n  \"type\" elwood.activity_type NOT NULL,\n  \"text\" text NOT NULL,  \n  \"attachments\" jsonb NOT NULL DEFAULT '{}'::jsonb,\n  \"created_at\" timestamptz default now(),\n  \"updated_at\" timestamptz default now(),\n  \n  CONSTRAINT \"elwood_activity_user_id\" FOREIGN KEY (\"user_id\") REFERENCES \"auth\".\"users\"(\"id\"),\n  CONSTRAINT \"elwood_activity_member_id\" FOREIGN KEY (\"member_id\") REFERENCES \"elwood\".\"member\"(\"id\"),\n  PRIMARY KEY (\"id\")\n);\n\nalter table elwood.\"activity\" enable row level security;\n\nDROP VIEW  IF EXISTS public.elwood_activity;\nCREATE VIEW public.elwood_activity with (security_invoker=on)\n  AS SELECT\n    \"a\".\"id\",\n    \"a\".\"user_id\",\n    \"a\".\"member_id\",\n    \"a\".\"asset_id\",\n    \"a\".\"asset_type\",\n    \"a\".\"is_deleted\",\n    \"a\".\"is_resolved\",\n    \"a\".\"type\",\n    \"a\".\"text\",  \n    \"a\".\"attachments\",\n    \"a\".\"created_at\",\n    \"a\".\"updated_at\"\n  FROM elwood.activity as a;\n\ncreate policy \"Members can view all activity.\"\non elwood.activity for select\nto authenticated\nusing (elwood.is_a_member());\n\ncreate policy \"Members can create activity.\"\non elwood.activity for insert\nto authenticated                     \nwith check (elwood.is_a_member());  \n\n\n-- BEFORE INSERT\nCREATE OR REPLACE FUNCTION elwood.before_activity_insert()\n  RETURNS TRIGGER\n  LANGUAGE PLPGSQL\nAS\n$$\nDECLARE\n  _user_id uuid := auth.uid();\n  _member_id uuid;\nBEGIN\n  SELECT id INTO _member_id FROM elwood.member WHERE user_id = _user_id;\n  NEW.member_id = _member_id;\n  -- users can only insert activity for themselves\n  NEW.user_id = _user_id;\n  RETURN NEW;\nEND;\n$$;\n\nCREATE TRIGGER trigger_before_activity_insert\nBEFORE INSERT\nON elwood.activity\nFOR EACH ROW\nEXECUTE FUNCTION elwood.before_activity_insert();\n\ncreate table if not exists elwood.follow (\n  \"instance_id\" uuid not null default '00000000-0000-0000-0000-000000000000',\n  \"id\" uuid not null default uuid_generate_v4(),\n  \"user_id\" uuid not null,\n  \"type\" elwood.follow_type not null DEFAULT 'SAVE',\n  \"asset_type\" text not null,\n  \"asset_id\" text not null,\n  \"is_active\" boolean not null default false,\n  \"created_at\" timestamptz default now(),\n  \"updated_at\" timestamptz default now(),\n\n  constraint \"elwood_follow_user_id\"\n    foreign key (\"user_id\") references \"auth\".\"users\" (\"id\"),\n\n  primary key (\"id\")\n);\n\ncreate unique index if not exists elwood_idx_follow_user_asset on elwood.follow (\n  \"user_id\",\n  \"type\",\n  \"asset_type\",\n  \"asset_id\"\n);\n\n\nalter table \"elwood\".\"follow\" enable row level security;\n\nDROP VIEW  IF EXISTS public.elwood_follow;\nCREATE VIEW public.elwood_follow with (security_invoker=on)\n  AS SELECT\n    \"id\",\n    \"user_id\",\n    \"type\",\n    \"asset_type\",\n    \"asset_id\",\n    \"is_active\",\n    \"created_at\",\n    \"updated_at\",\n    (split_part(asset_id, ':', 3) = 'blob')::boolean as is_object_blob,\n    (select name from storage.buckets where id = split_part(asset_id, ':', 4)) as bucket_name,\n    replace(\n      CASE\n        WHEN split_part(asset_id, ':', 5) = '' THEN NULL\n        ELSE (select name from storage.objects where id = split_part(asset_id, ':', 5)::uuid)\n      END,\n      '/.emptyFolderPlaceholder',\n      ''\n    ) as object_name\n  FROM elwood.follow;\n\ncreate policy \"Members can view their own follows.\"\non elwood.follow for select\nto authenticated\nusing (elwood.is_a_member() AND \"user_id\" = auth.uid());\n\ncreate policy \"Members can create their own follow.\"\non elwood.follow for insert\nto authenticated                     \nwith check (elwood.is_a_member() AND \"user_id\" = auth.uid());  \n\ncreate policy \"Members can update their own follow.\"\non elwood.follow for update\nto authenticated                     \nwith check (elwood.is_a_member() AND \"user_id\" = auth.uid());  \n\n\n-- BEFORE INSERT\nCREATE OR REPLACE FUNCTION elwood.before_follow_insert()\n  RETURNS TRIGGER\n  LANGUAGE PLPGSQL\nAS\n$$\nDECLARE\n  _user_id uuid := auth.uid();\nBEGIN\n  -- users can only insert activity for themselves\n  NEW.user_id = _user_id;\n  RETURN NEW;\nEND;\n$$;\n\nCREATE TRIGGER trigger_before_follow_insert\nBEFORE INSERT\nON elwood.follow\nFOR EACH ROW\nEXECUTE FUNCTION elwood.before_follow_insert();\n\ncreate table if not exists elwood.notification (\n  \"instance_id\" uuid not null default '00000000-0000-0000-0000-000000000000',\n  \"id\" uuid not null default uuid_generate_v4(),\n  \"user_id\" uuid not null,\n  \"type\" text not null default 'GENERIC',\n  \"data\" jsonb not null default '{}'::jsonb,\n  \"has_seen\" boolean not null default false,\n  \"seen_at\" timestamptz null,\n  \"bucket_id\" text null,\n  \"object_id\" uuid null,\n  \"created_at\" timestamptz default now(),\n  \"updated_at\" timestamptz default now(),\n\n  constraint \"elwood_notification_user_id\"\n    foreign key (\"user_id\") references \"auth\".\"users\" (\"id\"),\n  constraint \"elwood_follow_bucket_id\"\n    foreign key (\"bucket_id\") references \"storage\".\"buckets\"(\"id\"),\n  constraint \"elwood_follow_object_id\"\n    foreign key (\"object_id\") references \"storage\".\"objects\"(\"id\"),\n  primary key (\"id\")\n);\n\nalter table \"elwood\".\"notification\" enable row level security;\n\ndrop view if exists public.elwood_notification;\ncreate view public.elwood_notification with (security_invoker=on)\n AS SELECT\n    \"id\",\n    \"type\",\n    \"data\",\n    \"has_seen\",\n    \"seen_at\",\n    \"bucket_id\",\n    \"object_id\",\n    \"created_at\",\n    \"updated_at\"\n  from elwood.notification;\n\n\ncreate policy \"Members can view their own notifications.\"\non elwood.notification for select\nto authenticated\nusing (elwood.is_a_member() AND \"user_id\" = auth.uid());\n\ncreate policy \"Members can update their own notification.\"\non elwood.notification for update\nto authenticated                     \nwith check (elwood.is_a_member() AND \"user_id\" = auth.uid());  \n\n-- BEFORE INSERT\n\ncreate or replace function elwood.after_object_insert_or_update()\nreturns trigger\nlanguage PLPGSQL\nas $$\nDECLARE\n  _path_parts text[];\n  _path_parts_length int;\n  _prefix text[];\n  _part text;\n  _path_tokens text[];\nBEGIN\n\n  -- ignore if there is a file name\n  IF storage.filename(NEW.name) = '.emptyFolderPlaceholder' THEN\n    RETURN NEW;\n  END IF;\n\n  -- split the new path into parts\n  _path_parts := regexp_split_to_array(NEW.name, '/');\n  _path_parts_length := array_length(_path_parts, 1);\n\n  IF _path_parts_length = 1 THEN\n    RETURN NEW;\n  END IF;\n\n  -- now loop through each part and make sure there's an object\n  -- for the tree path so we can have an object id\n  FOREACH _part IN ARRAY _path_parts[1:_path_parts_length-1] LOOP\n    _prefix := _prefix || array[_part];\n    _path_tokens := _prefix || array['.emptyFolderPlaceholder'];\n\n    -- insert a placeholder object if it doesn't exist\n    INSERT INTO storage.objects (\"bucket_id\", \"owner_id\", \"name\") VALUES (\n      NEW.bucket_id,\n      NEW.owner_id,\n      array_to_string(\n        _path_tokens,\n        '/'\n      )\n    ) ON CONFLICT (\"bucket_id\",\"name\") DO NOTHING;\n  END LOOP;\n  \n\n  -- if we think this is a folder, insert a placeholder object \n  IF NEW.metadata IS NULL OR NEW.metadata->>'eTag' IS NULL THEN\n    _path_tokens := _path_parts || array['.emptyFolderPlaceholder'];\n\n   -- insert a placeholder object if it doesn't exist\n    INSERT INTO storage.objects (\"bucket_id\", \"owner_id\", \"name\") VALUES (\n      NEW.bucket_id,\n      NEW.owner_id,\n      array_to_string(\n        _path_tokens,\n        '/'\n      )\n    ) ON CONFLICT (\"bucket_id\",\"name\") DO NOTHING;\n  END IF;\n\n  RETURN NEW;\nEND;\n$$;\n\nDROP TRIGGER IF EXISTS trigger_after_object_insert_or_update on storage.objects;\ncreate trigger trigger_after_object_insert_or_update\nbefore insert on storage.objects\nfor each row\nwhen (pg_trigger_depth() < 1)\nexecute function elwood.after_object_insert_or_update();\n\n\nDROP FUNCTION IF EXISTS elwood.create_node_id(text, text, uuid);\nCREATE OR REPLACE FUNCTION elwood.create_node_id(\n  p_type public.elwood_node_type,\n  p_bucket text default null,\n  p_object_id uuid default null\n) RETURNS text\nAS $$\nDECLARE \n  _node_id text[];\n  _prefix_part text;\n  _prefix_parts text[];\nBEGIN\n  _node_id := ARRAY['urn', 'enid', lower(p_type::text)];\n\n  IF p_bucket IS NOT NULL THEN    \n    _node_id := _node_id || ARRAY[p_bucket::text];\n  END IF;\n\n  IF p_object_id IS NOT NULL THEN\n    _node_id := _node_id || ARRAY[p_object_id::text];\n  END IF;\n  \n  return array_to_string(_node_id,':');\nEND;\n$$ language plpgsql;\n\n\n\nDROP FUNCTION IF EXISTS elwood.create_node_id_for_tree(text[]);\nCREATE OR REPLACE FUNCTION elwood.create_node_id_for_tree(\n  p_path text[]\n) RETURNS text\nAS $$\nDECLARE \n  _bucket_id text;\n  _name text[];\n  _object_row storage.objects;  \n  _path_length int;\nBEGIN\n  _path_length := array_length(p_path, 1);\n  _bucket_id := ARRAY_TO_STRING(p_path[:1], '');\n  _name := p_path[2:] || ARRAY['.emptyFolderPlaceholder'];\n  \n  RAISE WARNING 'create_node_id_for_tree: p_path % || %', p_path, array_to_string(_name, '/');\n\n  SELECT * INTO _object_row FROM storage.objects WHERE \"bucket_id\" = _bucket_id AND \"name\" = array_to_string(_name, '/');\n\n  IF _object_row IS NULL THEN\n    return 'urn:enid:no_object_row_found';\n  END IF;\n  \n  return elwood.create_node_id('TREE', _bucket_id, _object_row.id);\n\nEND;\n$$ language plpgsql;\n\ndrop function if exists elwood.get_node_children(uuid, text[]);\ncreate or replace function elwood.get_node_children(p_prefix text[])\nreturns jsonb[]\nlanguage PLPGSQL\nas $$\nDECLARE \n    _bucket_row storage.buckets;\n    _search_row public.elwood_storage_search_result;    \n    _object_row public.elwood_node;\n    _nodes jsonb[];  \n    _node_type public.elwood_node_type;\n    _bucket_id text;\n    _prefix text;\n    _path text;\n    _depth int;\nBEGIN\n    _nodes := ARRAY[]::jsonb[];\n    _prefix := ARRAY_TO_STRING(p_prefix, '/');\n\n    -- if there's nothing in input then return the root\n    -- which is all the buckets\n    IF array_length(p_prefix, 1) IS NULL THEN    \n        FOR _bucket_row IN\n            SELECT * FROM storage.buckets\n        LOOP\n            _object_row.id := elwood.create_node_id('BUCKET', _bucket_row.name::text, null);\n            _object_row.type := 'BUCKET';\n            _object_row.prefix := p_prefix;\n            _object_row.name := _bucket_row.name;\n            _object_row.mime_type := 'inode/directory';\n            _object_row.size := (SELECT SUM(COALESCE((o.metadata->>'size')::int, 0)) FROM storage.objects as o WHERE o.bucket_id = _bucket_row.id);\n            _nodes := _nodes || ARRAY[to_jsonb(_object_row)];\n        END LOOP;\n    END IF;\n\n\n    _bucket_id := ARRAY_TO_STRING(p_prefix[:1], '');\n    _path := ARRAY_TO_STRING(p_prefix[2:], '/');\n    _depth := array_length(p_prefix[2:], 1) + 1;\n\n    IF _depth IS NULL THEN  \n        _depth := 1;\n    END IF;\n\n    RAISE WARNING 'get_node_children: p_prefix %, _bucket_id: %, _path: %, _depth: %', p_prefix, _bucket_id, _path, _depth;\n\n    FOR _search_row IN\n        SELECT * FROM storage.search(_path, _bucket_id, 100, _depth)\n    LOOP\n    RAISE WARNING 'get_node_children: _search_row %', _search_row.name;\n\n        IF _search_row.id IS NULL THEN\n\n        RAISE WARNING 'xxxx: xxx %', ARRAY[_bucket_id] || string_to_array(_path,'/')|| string_to_array(_search_row.name,'/');\n\n            _object_row.type := 'TREE';\n            _object_row.id := elwood.create_node_id_for_tree(ARRAY[_bucket_id] || string_to_array(_path,'/')|| string_to_array(_search_row.name,'/'));\n        ELSE \n            _object_row.type := 'BLOB'; \n            _object_row.id := elwood.create_node_id(_node_type, _bucket_id, _search_row.id);\n        END IF;\n\n        IF _search_row.name != '.emptyFolderPlaceholder' THEN\n            _object_row.prefix := p_prefix;\n            _object_row.name := _search_row.name;\n            _object_row.mime_type := _search_row.metadata->>'mimetype';\n            _object_row.size := COALESCE((_search_row.metadata->>'size')::int, 0);\n            _nodes := _nodes || to_jsonb(_object_row);\n        END IF;\n    END LOOP;\n\n    RAISE WARNING 'get_node_children: length _depth: %', array_length(_nodes, 1);\n\n    return _nodes;\nEND;\n$$;\n\n\n\nDROP FUNCTION IF EXISTS elwood.get_node_leaf(text[]);\nCREATE OR REPLACE FUNCTION elwood.get_node_leaf(\n  \"p_path\" text[]\n) RETURNS elwood.get_node_leaf_result LANGUAGE PLPGSQL\nAS $$\nDECLARE \n  _path_length int;\n  _name text;\n  _path text;\n  _prefix text[];\n  _bucket_id text;\n  _node public.elwood_node;\n  _bucket_row storage.buckets;\n  _object_row storage.objects;  \n  _result elwood.get_node_leaf_result;\nBEGIN\n  _path_length := array_length(p_path, 1);\n\n  -- no path means root\n  IF _path_length IS NULL THEN \n    _node.id = 'root';\n    _node.type = 'BUCKET';  \n    _node.prefix = ARRAY[]::text[];\n  END IF;\n\n  -- single path means bucket\n  IF _path_length = 1 THEN\n    SELECT * INTO _bucket_row FROM storage.buckets WHERE \"name\" = p_path[1];\n\n    IF _bucket_row.id IS NULL THEN\n      return null;\n    END IF; \n\n    _node.id = elwood.create_node_id('BUCKET', _bucket_row.name, null);\n    _node.type = 'BUCKET';\n    _node.prefix = ARRAY[]::text[];\n    _node.name = _bucket_row.name;\n    _node.mime_type = 'inode/directory';\n  END IF;\n\n  -- multiple paths means object\n  IF _path_length > 1 THEN\n    _bucket_id := ARRAY_TO_STRING(p_path[:1], '');\n    _prefix := p_path[1:_path_length-1];\n    _path := ARRAY_TO_STRING(p_path[2:], '/');\n    _name := p_path[_path_length];\n\n    SELECT * INTO _object_row FROM storage.objects WHERE \"bucket_id\" = _bucket_id AND \"name\" = _path;\n\n    IF _object_row.id IS NULL THEN\n      _node.id = elwood.create_node_id_for_tree(p_path);\n      _node.type = 'TREE';\n      _node.prefix = _prefix;\n      _node.name = _name;\n      _node.mime_type = 'inode/directory';      \n    END IF;\n      \n    IF _object_row.id IS NOT NULL THEN\n      _node.id = elwood.create_node_id('BLOB', _bucket_id, _object_row.id);\n      _node.type = 'BLOB';\n      _node.prefix = _prefix;\n      _node.name = _name;\n      _node.mime_type = _object_row.metadata->>'mimetype';\n      _node.size = COALESCE((_object_row.metadata->>'size')::int, 0);\n    END IF;\n  END IF;\n\n  _result.node := _node;\n\n  -- give it back\n  return _result;\n\nEND;\n$$;\n\n\n-- @@\n-- GET_NODE\n-- get a node with all the other info you might need for that node\ndrop function if exists public.elwood_get_node(text[], int, int);\ncreate or replace function public.elwood_get_node(\n  p_path text[],\n  p_limit int default 100,\n  p_offset int default 0\n)\nreturns jsonb\nas $$\nDECLARE \n  _node_leaf elwood.get_node_leaf_result;\n  _parent_leaf elwood.get_node_leaf_result;\n  _node public.elwood_node;  \n  _prefix text[];\n  _child_row jsonb;\n  _children jsonb[] = ARRAY[]::jsonb[];  \n  _key_children text[] = ARRAY[]::text[];\nBEGIN\n  -- get this node leaf\n  _node_leaf := elwood.get_node_leaf(p_path);\n  _node = _node_leaf.node;\n\n  -- no node means stop\n  IF _node.id IS NULL THEN\n    return null;\n  END IF;\n\n  -- if this isn't root, get the parent\n  IF _node.id != 'root' THEN\n    SELECT * INTO _parent_leaf FROM elwood.get_node_leaf(p_path[1:array_length(p_path, 1)-1]);\n    _prefix := _node.prefix || ARRAY[_node.name]::text[];\n  END IF;\n\n  IF _node.type = 'TREE' OR _node.type = 'BUCKET' THEN\n    _children := elwood.get_node_children(_prefix);\n\n    FOREACH _child_row IN ARRAY _children LOOP\n      IF (SELECT _child_row->>'name' = ANY(ARRAY['readme.md']::text[])) THEN\n        _key_children := _key_children || ARRAY[_child_row->>'name'];\n      END IF; \n    END LOOP;\n  END IF;\n\n  return jsonb_build_object(\n    'node', to_jsonb(_node),\n    'parent', to_jsonb(_parent_leaf.node),\n    'children', _children,\n    'key_children', _key_children\n  );\nEND;\n$$\nlanguage plpgsql;\n\ndrop function if exists public.elwood_get_node_tree(text[]);\ncreate or replace function public.elwood_get_node_tree(p_path text[])\nreturns jsonb\nas $$\nDECLARE \n  _id text;\n  _bucket_id text;\n  _path text;\n  _part text;\n  _result jsonb[];\n  _row jsonb;\n  _node_row jsonb;\n  _row_path text[];\n  _node_type public.elwood_node_type;\n  _expanded_ids text[]; \n  _path_id text;\n  _leaf elwood.get_node_leaf_result;\n  _leaf_node public.elwood_node;\n  _root_id text := 'root';\nBEGIN\n\n  IF array_length(p_path, 1) > 0 THEN\n    _root_id := elwood.create_node_id('BUCKET', array_to_string(p_path[0:1],'')::text, null);\n  END IF;\n\n  FOREACH _part IN ARRAY p_path LOOP\n    _row_path := _row_path || _part;\n    _node_row := elwood_get_node(_row_path);\n    \n    -- if this is a blob, it will be added when we loop to the parent\n    -- so don't push it to the row now\n    IF (_node_row->'node')::jsonb->>'type' != 'BLOB' THEN\n\n      _result := _result || jsonb_build_object(\n        'id', (_node_row->>'node')::jsonb->>'id',\n        'node', _node_row->'node',\n        'parent', (_node_row->'parent')::jsonb->>'id'\n      );\n\n      _expanded_ids := _expanded_ids || ARRAY[(_node_row->>'node')::jsonb->>'id'::text];\n\n      FOR _row IN SELECT jsonb_array_elements FROM jsonb_array_elements(_node_row->'children') LOOP\n        _result := _result || jsonb_build_object(\n          'id', _row->>'id',\n          'node', _row,\n          'parent', (_node_row->>'node')::jsonb->>'id'\n        );\n      END LOOP;\n    END IF;\n\n  END LOOP;\n\n\n  RETURN jsonb_build_object(\n    'rootNodeId', _root_id,\n    'expandedIds', _expanded_ids,\n    'tree', _result\n  );\n\nEND;\n$$\nlanguage plpgsql;\n"
}